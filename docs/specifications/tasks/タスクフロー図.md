# タスクフロー図

## 概要

TimeManagerとTaskManagerを中心とした「投げ下ろし設計」のフロー図です。各コンポーネントが明確な責任を持ち、上位→下位への一方向依存を維持しています。

## 1. 基本タスク割り当てフロー（実装ベース）

```mermaid
sequenceDiagram
    participant TM as TimeManager
    participant TaskMgr as TaskManager
    participant TC as TeamComponent
    
    Note over TM: ProcessTimeUpdate() - ターンベース処理開始
    
    loop 各チーム（TeamComponents配列）
        TM->>TC: GetTeam(TeamIndex)
        TC-->>TM: Team状態（ActionState、AssignedTask等）
        Note over TM: 戦闘中・移動中チェック
        
        alt チームが戦闘中
            Note over TM: Team.ActionState == InCombat
            TM->>TM: MonitorLockedAction(TeamIndex)
            Note over TM: 戦闘処理は内部実装
            
        else チームが通常状態
            Note over TM: 現在のAssignedTaskで分岐
            
            alt AssignedTask == Gathering
                TM->>TM: ProcessGatheringTask(TeamIndex)
                Note over TM: 採集実行処理
                
            else AssignedTask == Adventure  
                TM->>TM: ProcessAdventureTask(TeamIndex)
                Note over TM: 冒険実行処理
                
            else AssignedTask == All
                TM->>TM: ProcessAllModeTask(TeamIndex)
                Note over TM: 全てモード処理
            end
        end
    end
    
    Note over TM: TaskManagerへの問い合わせは各Processメソッド内で実行
```

## 2. 採集タスク詳細フロー

```mermaid
sequenceDiagram
    participant TM as TimeManager
    participant TC as TeamComponent
    participant MC as MovementComponent
    participant GC as GatheringComponent
    participant IM as ItemManager
    
    Note over TM: ProcessGatheringTask実行
    TM->>TC: GetCurrentLocation(TeamIndex)
    TC-->>TM: 現在地ID
    
    TM->>IM: CanExecuteGatheringAt(ItemId, LocationId)
    IM-->>TM: 採集可能性
    
    alt 現在地で採集可能
        TM->>TC: GetGatheringComponent()
        TC-->>TM: GatheringComponent参照
        TM->>GC: ExecuteGathering(TeamIndex, ItemId)
        Note over GC: 採集実行（TimeManagerは詳細知らない）
        
    else 移動が必要
        TM->>IM: FindLocationForItem(ItemId)
        IM-->>TM: 目標地点ID
        TM->>TC: GetMovementComponent()
        TC-->>TM: MovementComponent参照
        TM->>MC: ExecuteMovementStep(TeamIndex, TargetLocation)
        Note over MC: 移動実行（TimeManagerは詳細知らない）
    end
```

## 3. 冒険タスク→戦闘フロー（実装ベース）

```mermaid
sequenceDiagram
    participant TM as TimeManager
    participant TaskMgr as TaskManager
    participant TC as TeamComponent
    participant MC as MovementComponent
    participant CC as CombatComponent
    
    Note over TM: ProcessAdventureTask(TeamIndex)実行
    TM->>TC: GetTeam(TeamIndex)
    TC-->>TM: Team（現在状態含む）
    Note over TM: チーム状態確認（戦闘中ならスキップ）
    
    TM->>TM: GetCurrentLocation(TeamIndex)
    Note over TM: 内部実装で現在地取得
    
    alt 拠点にいる場合（目的地決定）
        TM->>TaskMgr: GetGlobalTasksByPriority()
        TaskMgr-->>TM: 全タスク配列
        Note over TM: ローカルループで冒険タスク検索
        TM->>TC: SetTeamGatheringLocation(TeamIndex, TargetLocation)
        Note over TC: 目的地設定
        
    else 目標地点に未到着
        TM->>TM: ExecuteMovementStep(TeamIndex, TargetLocation)
        Note over TM: 移動処理実行
        
    else 目標地点に到着
        TM->>TC: GetCombatComponent()
        TC-->>TM: CombatComponent参照
        TM->>CC: IsInCombat()
        CC-->>TM: false（戦闘中でない）
        
        alt 戦闘開始
            TM->>TC: GetTeam(TeamIndex)
            TC-->>TM: Team.Members
            Note over TM: 味方チーム取得
            
            TM->>CC: StartCombatSimple(Team.Members, EnemyTeam)
            Note over CC: 戦闘初期化
            TM->>TC: SetTeamActionState(TeamIndex, InCombat)
            Note over TC: チーム状態変更
            
        else 戦闘継続
            TM->>CC: ProcessCombat(0.0f)
            Note over CC: 1ターン戦闘処理
        end
    end
```

## 4. 戦闘中処理フロー（行動ゲージシステム）

```mermaid
sequenceDiagram
    participant TM as TimeManager
    participant CC as CombatComponent
    participant ASC as ActionSystemComponent
    participant Char as Character
    
    Note over TM: 毎ターン戦闘処理
    loop 戦闘継続中
        TM->>CC: ProcessCombat(DeltaTime)
        Note over CC: TimeManagerから毎ターン呼び出し
        
        CC->>ASC: ProcessSingleTurnWithGauge()
        Note over ASC: 1ターン1行動処理
        
        ASC->>ASC: CleanupInvalidCharacters()
        Note over ASC: 無効キャラクター除去
        
        ASC->>ASC: UpdateAllGauges()
        Note over ASC: 全キャラクターのゲージ更新
        
        ASC->>ASC: GetNextActingCharacterWithGauge()
        Note over ASC: 最高ゲージキャラクター選択
        
        alt 行動可能キャラクターあり
            ASC->>Char: ProcessCharacterAction()
            Note over Char: キャラクターが行動実行
            ASC->>ASC: ResetCharacterGauge()
            Note over ASC: 行動後ゲージリセット
            ASC-->>CC: true（行動処理完了）
        else 行動可能キャラクターなし
            ASC-->>CC: false（誰も行動しない）
        end
        
        CC->>CC: CheckCombatCompletion()
        Note over CC: 勝敗判定
        
        alt 戦闘継続
            Note over TM,ASC: 次ターンへ
        else 戦闘終了
            CC->>CC: ExecuteCombatEndSequence()
            Note over CC: 戦闘終了処理
        end
    end
```

## 5. 戦闘終了→タスク再開フロー

```mermaid
sequenceDiagram
    participant CC as CombatComponent
    participant TC as TeamComponent
    participant ASC as ActionSystemComponent
    participant EM as EventManager
    participant TM as TimeManager
    participant TaskMgr as TaskManager
    
    Note over CC: 戦闘終了検出
    CC->>CC: ExecuteCombatEndSequence()
    
    CC->>EM: LogCombatEnd(Winners, Losers, Duration)
    Note over EM: 戦闘ログ記録
    
    CC->>ASC: StopActionSystem()
    Note over ASC: 行動システム停止
    
    CC->>ASC: ClearAllCharacters()
    Note over ASC: キャラクター登録解除
    
    CC->>TC: SetTeamActionState(Idle)
    Note over TC: チーム状態リセット
    
    CC->>CC: SetCombatState(Inactive)
    Note over CC: 戦闘状態リセット
    
    Note over TM: 次ターン処理
    TM->>CC: IsInCombat()
    CC-->>TM: false（戦闘終了）
    
    TM->>TaskMgr: DetermineOptimalTask(TeamIndex)
    Note over TM: 戦闘中断不可能性が解除され、通常タスク再開
    TaskMgr-->>TM: 次の最適タスク
```

## 6. 委譲型設計の責任境界

```mermaid
graph TB
    subgraph "フロー制御層"
        TM[TimeManager]
    end
    
    subgraph "データプロバイダー層"
        TaskMgr[TaskManager]
        IM[ItemManager]
        LEM[LocationEventManager]
    end
    
    subgraph "状態管理層"
        TC[TeamComponent]
    end
    
    subgraph "実行エンジン層"
        MC[MovementComponent]
        GC[GatheringComponent]
        CC[CombatComponent]
        ASC[ActionSystemComponent]
    end
    
    TM -->|データ取得| TaskMgr
    TM -->|データ取得| IM
    TM -->|データ取得| LEM
    TM -->|状態取得/参照取得| TC
    TM -->|処理委譲| MC
    TM -->|処理委譲| GC
    TM -->|処理委譲| CC
    
    CC -->|行動処理委譲| ASC
    TC -->|状態変更通知| TM
    
    style TM fill:#e1f5fe
    style TaskMgr fill:#f3e5f5
    style IM fill:#f3e5f5
    style LEM fill:#f3e5f5
    style TC fill:#e8f5e8
    style MC fill:#fff3e0
    style GC fill:#fff3e0
    style CC fill:#fff3e0
    style ASC fill:#fff3e0
```

## 現在の設計問題と改善提案

### ❌ 現在の問題点

1. **責任の混在**: TimeManagerがタスクの詳細構造を知っている
2. **重複実装**: TaskManagerとTimeManagerで同様のロジック
3. **直接的状態変更**: TimeManagerから下位への状態変更指示

### ✅ 推奨される改善設計

```mermaid
sequenceDiagram
    participant TM as TimeManager
    participant TaskMgr as TaskManager
    participant TC as TeamComponent
    participant CC as CombatComponent
    
    Note over TM: より良い委譲設計
    TM->>TaskMgr: FindOptimalTaskForTeam(TeamIndex)
    TaskMgr-->>TM: TaskResult（タスクID＋実行指示）
    Note over TM: タスク詳細は知らない、結果のみ受領
    
    TM->>TC: ExecuteTaskResult(TaskResult)
    Note over TC: TeamComponentが実行詳細を担当
    
    alt 冒険タスクの場合
        TC->>TC: HandleAdventureTask(TaskResult)
        TC->>CC: PrepareForCombat(LocationId)
        Note over CC: 戦闘準備は戦闘専門コンポーネントが担当
    end
```

### 理想的な責任分担

1. **TimeManager**: タスク結果の受領と実行委譲のみ
2. **TaskManager**: 全タスクロジック（場所選択含む）を担当
3. **TeamComponent**: チーム状態管理と実行調整
4. **CombatComponent**: 戦闘専門処理

### データ駆動設計の実現
- TimeManagerは`TaskResult`構造体のみ処理
- タスク種別の詳細判定はTaskManagerに完全委譲
- 各コンポーネントが自分の専門領域のみ担当